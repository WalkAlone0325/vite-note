> 面试相关

## 1. 为什么使用 虚拟DOM

::: tip
1. 创建真实 DOM 的代码高：真实 DOM 节点 node 的属性很多，而是用 vnode 仅实现一些必要的属性
2. 触发多次浏览器的重绘和回流：使用 vnode，相当于加了一个缓存，让一次数据变动先在 `vnode` 进行修改，然后diff之后对所有产生差异的节点集中一次对 `DOM tree` 进行修改，可以减少浏览器的 重绘 和 回流
3. 虚拟DOM本质是一个js对象，具备跨平台的能力，可以实现不同平台的准确显示
4. vnode 不仅在性能上有很好的收益，也使得 Vue 具备了现代框架应有的高级特性
:::

## 2. Vue 组件通信

::: tip
1. 父向子组件传值

    - 父组件发送的形式以属性的形式绑定到子组件上
    - 然后子组件使用 `props` 接收
    - 在 `props` 中使用驼峰形式，在模版中可以使用短横线形式

2. 子向父组件传值

    - 子组件使用 `$emit()` 触发事件
    - `$emit()` 第一个参数为 `自定义事件名称`，后续参数为所传递的 数据
    - 父组件使用 `v-on` 缩写为 `@` 监听子组件的事件

3. 兄弟之间的传值

    - `provide inject`
    - `vuex pinia`
    - `eventBus`
:::

## 3. Vue 中 key 的作用，为什么不推荐使用 index 作为 key

::: tip
1. key 的作用主要是为了高效的更新虚拟 DOM（直接会根据key 的变化重新排列元素的属性，并移除 key 不存在的元素）
2. 当以数组的下标index作为key时，其中一个元素（增删改查）发生了变化可能会导致所有元素的 key 值发生变化
:::

## 4. `v-show` 和 `v-if` 的区别

::: tip 
- `v-show` 原理是修改元素的 css 属性 `display: none` 来决定是否显示元素

- `v-if` 是用通过 三元表达式 直接判断和操作 DOM 来切换显示
:::

## 5. Vue 导航守卫的钩子函数有哪些

::: tip
全局守卫
1. `router.beforeEach` 全局前置守卫，进入路由前
2. `router.beforeResolve` 全局解析守卫，在 `beforeRouteEnter` 调用之后调用
3. `router.afterEach` 全局后置钩子，进入路由之后

路由组件内的守卫
1. `beforeRouteEnter()` 进入路由前
2. `beforeRouteUpdate()` 路由复用同一个组件时
3. `beforeRouteLeave()` 离开当前路由时
:::

## 6. Vue 编程式导航跳转传参的方式有哪些

::: tip
```js
// 命名的路由
router.push({ name: 'user', params: { userId: 'xx' } })

// 带查询参数，变成 /register?plan=xxx
router.push({ path: 'register', query: { plan: 'xx' } })
```
:::

## 7. Vue3 性能提升的几个方面

::: tip
1. 编译阶段
   1. `diff` 算法优化 （最长递增子序列）(静态标记，会发生变化的地方添加 `flag`，发生变化时直接找该地方进行比较)
   2. 静态提升（不参与更新的元素，做静态提升，只会被创建一次，在渲染时直接复用）
   3. 事件监听缓存（开启事件缓存，diff 算法时直接复用）
   4. `SSR` 优化

2. 源码体积
   1. 移除了一些不常用的 API
   2. `tree shanking`

3. 响应式系统
   1. `vue2` 使用 `defineProperty` 来劫持整个对象，然后深度遍历所有属性，给每个属性添加 `getter` 和 `setter` 来实现响应式
   2. `vue3` 使用 `proxy` 重写了响应式系统，因为 `proxy` 可以对真个对象进行监听，不需要深度遍历
      - 可以监听动态属性的添加
      - 可以监听数组的 `索引` 和数组的 `length` 属性
      - 可以监听 删除属性
:::

## 8. `Composition API` 和 `Options API` 对比

::: tip
1. 在 逻辑组织 和 逻辑复用 方面，前者优于后者
2. 前者几乎都是函数，所有 `ts` 类型推断更好的支持
3. 前者的 `tree-shanking` 更友好，代码更容易压缩
4. 前者减少了 `this` 的使用，避免了出现 `this` 指向不明的情况
5. 对于小型组件，后者更为方便
:::

## 9. Vue3 和 Vue2 对比，以及 Vue3 的新特性

::: tip
1. 速度更快
   1. 重写了 `虚拟Dom` 实现
   2. 编译模版的优化
   3. 更高效的组件初始化
   4. `undate` 性能提升 1.3~2 倍
   5. `SSR` 速度提高了 2~3 倍
2. 体积更小
   1. 对开发人员，能够对Vue实现更多的其它功能，不用担心包的体积过大
   2. 对使用者，打包出来的包体积变小了
3. 更易维护
   1. 可与 `Options API` 一起使用
   2. 灵活的逻辑组合与复用
   3. Vue3 单模块可以与其他框架搭配使用
   4. 更好的 TS 支持
4. 更接近原生
   1. 可以自定义渲染器 API
5. 更易使用
:::

::: tip
Vue3 的新特性

1. `Framents` （多根节点）
2. `Teleport` （传送门）
3. `Suspense` （异步组件）
4. `Composition API` （组合式 API）
5. `createRenderer` （自定义渲染器）
:::

## 10. diff 算法比较

::: tip
1. 简单 Diff 算法
   
   > 简单 Diff 算法的核心逻辑是，拿新的一组子节点的节点去旧的一组子节点中寻找可复用的节点。如果找到了，则记录该节点的位置索引。我们把这个位置索引称为最大索引。在整个更新过程中，如果一个节点的索引值小于最大索引，则说明该节点对应的真实DOM元素需要移动。

2. 双端 Diff 算法

   > 双端 Diff 算法指的是，在新旧两组子节点的四个端点之间分别进行比较，并试图找到可复用的节点。相比简单 Diff 算法，双端 Diff 算法的优势在于，对于同样的更新场景，执行的DOM移动操作次数更少。

3. 快速 Diff 算法

   > 快速 Diff 算法在实测中性能更优，先处理新旧两组子节点中相同的前置节点和后置节点。当前置节点和后置节点都处理完成后，如果无法简单的通过挂载节点或卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构造出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。（其中元素值 为 -1 的则为需要新增的节点）
:::
